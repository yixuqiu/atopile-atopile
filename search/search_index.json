{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Code to Electronics","text":"<p>Welcome to atopile - code to electronics</p>"},{"location":"building/","title":"Building your ato project","text":""},{"location":"building/#building-predefined-entry-points","title":"Building predefined entry points","text":"<p>The <code>ato.yaml</code> file can contain predefined build configurations. Those can be defined like so:</p> <p>ato.yml</p> <pre><code>...\nbuilds:\n    default:\n        entry: elec/src/your-project.ato:YourModule\n    build-2:\n        entry: elec/src/your-second-project.ato:YourSecondModule\n...\n</code></pre> <p>The <code>ato build</code> command will build the atopile modules for all of those entry points.</p> <p>For a specific build, you can use the -b or --build option like so: <pre><code>ato build -b build-name\n</code></pre> or <pre><code>ato build --build build-name\n</code></pre></p>"},{"location":"building/#building-a-given-entry-point","title":"Building a given entry point","text":"<p>A given entry point can be built like so from your atopile project directory:</p> <pre><code>ato build elec/src/your-project.ato:YourModule\n</code></pre>"},{"location":"building/#building-given-targets","title":"Building given targets","text":"<p>Those are the targets that can currently be built by atopile:</p> <ul> <li>Netlist (\"netlist\")</li> <li>Bill Of Material (\"bom\")</li> <li>Designator Map (\"designator-map\")</li> <li>Manufacturing Data (\"mfg-data\")</li> <li>Consolidate footprint (\"copy-footprints\")</li> <li>All of the above (\"all\")</li> </ul> <p>The target can be specified with the <code>-t</code> or <code>--target</code> like so:</p> <p><pre><code>ato build -t target-name\n</code></pre> or <pre><code>ato build --target target-name\n</code></pre></p>"},{"location":"ci/","title":"Generation of build outputs","text":"<p>Continuous integration / continuous distribution (CI/CD) is a powerful process to automatically export and deploy your project to production.</p>"},{"location":"ci/#continuous-integration-continuous-distribution","title":"Continuous integration / continuous distribution","text":"<p>Our CI pipeline will automatically generate the following outputs for you:</p> <ul> <li>Gerbers (with githash automatically stamped on it!)</li> <li>BOM</li> <li>Pick and place file</li> </ul> <p>Our template project has an example of a GitHub actions workflow.</p>"},{"location":"ci/#github-actions-artifacts","title":"GitHub actions artifacts","text":"<p>To download the artifacts, go to the github action page, find the pipeline with the commit you are interested in and download the build artifacts from it.</p>"},{"location":"class/","title":"Class, subclass and replace","text":""},{"location":"class/#class-and-subclass","title":"Class and subclass","text":"<p>Like classes in most modern languages, we can subclass and inherit from blocks.</p> <pre><code>module SomeModule:\n    signal some_signal\n    signal gnd\n    some_variable = \"some value\"\n\nmodule SubclassedModule from SomeModule:\n    # inherits all the signals and variables from SomeModule\n    # we don't need to declare the signals again,\n    # but we will replace the value of some_variable\n    some_variable = \"some other value\"\n\nmodule Test:\n    signal gnd\n    # creates an instance of the SubclassedModule\n    subclased_module = new SubclassedModule\n    # connects the some_signal of the SubclassedModule to the gnd of Test\n    subclased_module.gnd ~ gnd\n</code></pre> <p>note: we can subclass a module as a component, but not the other way around. A component is expected to represent a specific component.</p> <p>This subclassing is also useful for creating typed interfaces:</p> <pre><code>interface I2C:\n    signal sda\n    signal scl\n\nmodule SomeModule:\n    i2c = new I2C\n\nmodule Test:\n    a = new SomeModule\n    b = new SomeModule\n    a.i2c ~ b.i2c  # connects both sda and scl in one fell swoop\n</code></pre>"},{"location":"class/#-the-replace-operator","title":"<code>-&gt;</code> the replace operator","text":"<p>This operator allows you to increase the specificity of a block somewhere.</p> <p>Take the following example: 1. You want to create a reusable half-bridge module 2. If you spec the FETs within the module, you can't readily reuse the design in other projects with other FETs 3. If you don't declare the FETs at the bottom level it's a PITA to use, since every time you use it you need to remember to slot the FET in the right spot</p> <p>You want some way to say \"we're putting a FET here, but we'll tell you which FET later\"</p> <p>Subclassing is the way you say what a FET is, the replacement operator gives you the later.</p> <pre><code>module NFET:\n    signal gate\n    signal source\n    signal drain\n\nmodule HalfBridge:\n    signal high\n    signal low\n    signal output\n    signal high_gate\n    signal low_gate\n\n    high_fet = new NFET\n    low_fet = new NFET\n\n    # let's pretend we do something useful here like hook it all up\n\n# some time later... perhaps in another file\n\ncomponent SomeNFET from NFET:\n    footprint = \"TO-220-3_Vertical\"\n    # this isn't a legit package, but you get the idea\n\nmodule MotorController:\n    a = new HalfBridge\n    # ...\n    # replace the fets with a SomeNFET\n    a.high_fet -&gt; SomeNFET\n    a.low_fet -&gt; SomeNFET\n</code></pre>"},{"location":"config/","title":"Project configuration","text":""},{"location":"config/#versioning","title":"Versioning","text":"<p>Versions within atopile follow the semantic versioning 2.x schema. See https://semver.org for details Semantic versions may be prefixed with a \"v\", so <code>v1.0.0 == 1.0.0</code></p>"},{"location":"config/#atoyaml-project-config","title":"<code>ato.yaml</code> project config","text":"<p>The <code>ato.yaml</code> is significant indicator for a project:</p> <ol> <li>It marks the root of a project. The <code>ato</code> commands in the CLI is largely dependant upon the <code>ato.yaml</code> to know what project you're referring to.</li> <li>It contains project-level configuration information like where to build from, which layouts have what entry-points</li> <li>Lists project dependencies and the required versions of those dependencies</li> <li>Specifies what compiler version the project is intended to build with</li> </ol>"},{"location":"config/#build-key","title":"<code>build</code> key","text":"<p>This is for build-configuration information.</p> <p>Each key under <code>build:</code> is a layout name, and the value is a list of entry-points for that layout.</p> <p>eg. <pre><code>build:\n  my-build:\n    entry: \"elec/src/demo.ato:Demo\"  # This is the root of the build\n</code></pre></p> <p><code>fail_on_drcs</code> is a boolean value, defaulting to <code>false</code>. If set to <code>true</code>, the build will fail if any DRCs errors are found.</p>"},{"location":"config/#dependencies","title":"Dependencies","text":"<p>Each package listed under the <code>dependencies:</code> key is automatically downloaded and installed for users when they run the <code>ato install</code> command from within a project. These dependencies are anticipated to make the project run.</p> <p>Each dependency may have constraints on its version using the following operators:</p> <p>Assuming dependency says <code>my-package &lt;operator&gt;1.2.3</code> the following table describes whether each of the operators would match.</p> <p>They're in approximate order of usefulness/recommendation</p> Op <code>0.1.1</code> <code>1.1.0</code> <code>1.2.3</code> <code>1.2.4</code> <code>1.3.0</code> <code>1.4.0</code> <code>2.0.0</code> Description <code>^</code> \u2714 \u2714 \u2714 \u2714 &gt;=, up to the next major <code>~</code> \u2714 \u2714 &gt;=, up to the next minor <code>==</code> \u2714 Exactly <code>*</code> \u2714 \u2714 \u2714 \u2714 \u2714 \u2714 \u2714 Any <code>!</code> \u2714 \u2714 \u2714 \u2714 \u2714 \u2714 Not (usually used in combination with others) <p><code>&gt;=</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&lt;</code> all work, but have niche value. If you need to use them, something's probably broken.</p>"},{"location":"config/#compiler-version","title":"Compiler version","text":"<p>eg. <code>ato-version: v0.1.8</code></p> <p>The installed compiler is matched against this value to see if the project is buildable in the current environment.</p> <p>It's matched using either: - <code>~</code> if the installed compiler version <code>&lt;1.0.0</code> - else <code>^</code> (up to the next major)</p> <p>Practically, this means breaking compiler changes are indicated using the minor (eg. <code>0.1.0</code>, <code>0.2.0</code>, <code>0.3.0</code>, <code>0.4.0</code>) until version <code>1.0.0</code>.</p> <p>When you upgrade your compiler with breaking changes, you need to update your project to match the language changes, bumping this version in your project's <code>ato.yaml</code> file</p>"},{"location":"connect/","title":"Come join in","text":""},{"location":"connect/#discord","title":"Discord","text":""},{"location":"development/","title":"Development Guide","text":""},{"location":"development/#prerequisites","title":"Prerequisites","text":"<ul> <li>Install atopile via git</li> </ul>"},{"location":"development/#dev-tools","title":"Dev Tools","text":"<p>We recommend VSCode for development. If nothing else, it has heaps of high quality extensions and atopile language support, plus it's what we all use internally - so we know how to configure it for purpose.</p> <p>You should have at minimum: - VSCode - VSCode atopile extension - Python Extension for VSCode</p>"},{"location":"development/#verbosity","title":"Verbosity","text":"<p>You can increase the verbosity of atopile by using the <code>-v</code> of <code>-vv</code> flags, eg. <code>ato -vv build</code></p> <p>Flag Location</p> <p>Flags are placed after the <code>ato</code> command and before the command you want to run. For example, <code>ato -vv build</code> will run the build command with the verbose flag set to the highest level, while <code>ato build -vv</code> will not work.</p>"},{"location":"development/#debugging","title":"Debugging","text":"<p>You can start the CLI in debug mode by using the <code>--debug</code> flag, eg. <code>ato --debug build</code></p> <p>This will run a <code>debugpy</code> server on port <code>5678</code> which you can connect to with the VSCode built-in debugger.</p> <p></p> Syntax highlighting isn't working <p>If you're having trouble with syntax highlighting in the debugger, it might be because VSCode sets up a mapping between the remote and local file paths by default - remove it.</p>"},{"location":"development/#viewer-development","title":"Viewer development","text":""},{"location":"development/#building-the-viewer","title":"Building the viewer","text":"<p>You first need to build the viewer when installing atopile from it's repository directly. First, navigate to the viewer directly:</p> <pre><code>cd src/atopile/viewer\n</code></pre> <p>Then install the node dependencies:</p> <pre><code>npm install\n</code></pre> <p>Finally, build the viewer:</p> <pre><code>npm run build\n</code></pre> <p>This will create a <code>dist</code> directory within the viewer directory. Invoking the <code>ato view</code> command will point the server to it.</p>"},{"location":"development/#dev-viewer-server","title":"Dev viewer server","text":"<p>When working on the viewer, it is quite handy to use the following command to start a dev server:</p> <pre><code>npm run dev\n</code></pre> <p>As you save your work, vite will automatically rebuild your project and advertise it on a local address. Navigate to the address to inspect your work. We recommend running the <code>ato view</code> command from one of your existing projects, so you have a project to look at during development.</p>"},{"location":"doc-strings/","title":"Doc-strings","text":"<p>Doc-strings should be used to add in-code documentation of modules.</p> <p>eg. <pre><code>module MyModule:\n    \"\"\"\n    This is a hiiiiigh quality module!\n    \"\"\"\n</code></pre></p> <p>This documentation not only helps you remember what you did, but also means your package is searchable and useable by others.</p>"},{"location":"first_project/","title":"Creating an ato project","text":""},{"location":"first_project/#project-structure-setup","title":"Project structure setup","text":""},{"location":"first_project/#with-ato-create-recommended","title":"With <code>ato create</code> recommended","text":"<p>To create a project, you can run the command</p> <pre><code>ato create\n</code></pre> <p>This command will start by asking for a name to your project. It will then clone the project template on github. Once created on GitHub, paste your repository URL into the command line. Your project should be up and running!</p> <p>We also added a firmware and mech folder to store 3D designs or firmware associated with your project. Version controlling everything under the same project can be quite handy.</p>"},{"location":"first_project/#manually","title":"Manually","text":"<p>You can create your own project instead of using ato create. Perhaps you will want to setup the project and for it as you create your ato projects. Make sure to follow this project structure:</p> <pre><code>.\n\u251c\u2500\u2500 venv -&gt; (active) virtual environment with python^3.11 and atopile installed\n\u2514\u2500\u2500 your-project\n    \u251c\u2500\u2500 ato.yaml --&gt; definition file for your atopile project\n    \u251c\u2500\u2500 elec --&gt; your virtual environment\n    \u2502    \u251c\u2500\u2500 src\n    \u2502    \u2502   \u2514\u2500\u2500 file.ato\n    \u2502    \u2514\u2500\u2500 layout\n    \u2502        \u2514\u2500\u2500 default\n    \u2502            \u251c\u2500\u2500 kicad-project.kicad_pro\n    \u2502            \u251c\u2500\u2500 kicad-project.kicad_pcb\n    \u2502            \u251c\u2500\u2500 kicad-project.kicad_sch\n    \u2502            \u2514\u2500\u2500 fp-lib-table\n    \u2514\u2500\u2500 ci/cd file --&gt; useful for running jobs automatically on your repo\n</code></pre> <p>Tip</p> <p>Our template project contains example code for a github CI workflow to compile your ato files and access your manufacturing files from kicad. Find it here.</p>"},{"location":"first_project/#atoyaml-setup","title":"<code>ato.yaml</code> setup","text":"<p>The root of an ato project is marked by the presence of an <code>ato.yaml</code> file.</p> <p><code>ato.yaml</code> contains some project configuration information like the list of things you want to build. It's similar in concept to a package.json in js/node/npm land.</p> <p>Here's an example:</p> <pre><code># this line defines the version of compiler required to compile the project\nato-version: ^0.0.18\n# those lines define the elements that will be built by the compiler\nbuilds:\n  default:\n    entry: elec/src/your-project.ato:YourProject\n# The compiler version follows semantic versioning. The required version to compile your project can be specified using npm's standard.\n\n# Those lines define the package dependencies that your project might have. You can specify the exact package version you want using semantic versioning.\ndependencies:\n- generics^v1.0.0\n</code></pre> <p>Tip</p> <p>The compiler version follows sementic versioning. The required version to compile your project can be specified using npm's standard. The same applies to your dependencies.</p>"},{"location":"first_project/#building-the-project","title":"Building the project","text":"<p>To test that your project is building, run:</p> <p><code>ato build</code></p> <p>Tip</p> <p><code>ato build</code> will build the default module and kicad layout. You can specify a specific target with:</p> <p><code>ato build --build [name_of_your_build]</code></p> <p>The build name is defined in the <code>ato.yaml</code> file.</p> <p>You should see a build directory appear in your project structure. This is where atopile places the output files generated from compilation.</p>"},{"location":"getting-started/","title":"Getting started","text":"<p><code>atopile</code> brings the best of software development to the world of hardware design.</p> <p>We're starting with an electronics compiler and a new language called <code>ato</code>. Files with the <code>.ato</code> extension can be used to describe your circuit, and compiles it to netlists that can be laid out and fabricated.</p> <p>The <code>.ato</code> files are human readable and can be version controlled, so you can collaborate with your team on the design of your hardware. They're modular, so you can reuse components from other projects, and share them with the community. They provide a way to save the intelligence of your design and the validation required to make sure it works as intended, so you can be confident that your design will work as expected.</p>"},{"location":"getting-started/#overview","title":"Overview","text":"<ol> <li> <p>Install tools: See the install section below.</p> </li> <li> <p>Project Setup: For instructions on creating a new ato project from the command line, refer to ato create. Highly recommended to use GitHub to store and version your project.</p> </li> <li> <p>Install Packages: For detailed instructions on finding and installing pre-made packages for your project, refer to the installation guide. </p> </li> <li> <p>Circuit Design with Code: Hook up your circuit features using the expressive <code>ato</code> language, transforming your design ideas into precise, codified representations.</p> </li> <li> <p>Version Control: Commit and merge your features using git, iterating through the design process by repeating the steps of adding features and refining your design.</p> </li> <li> <p>Build and Export: Use <code>ato build</code> to compile your design into a netlist, which can then be imported into KiCAD for layout.</p> </li> <li> <p>Sync and Layout: Import netlist into the linked kicad project. Our packages installed from packages.atopile.io have a linked layout that you can reuse verbatim or as a known good starting point for your design.   Layout reuse in atopile</p> </li> <li> <p>Finalize and Order: Commit and merge your layout changes, then download the CI build of your design to order your custom PCB from JLCPCB.</p> </li> </ol>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>To run atopile, you will need the atopile compiler, the VSCode extension for syntax highlighting and git credential manager.</p>"},{"location":"getting-started/#atopile-compiler-with-pipx-recommended","title":"atopile compiler - with <code>pipx</code> recommended","text":"<p>atopile is published as a python package on pypi. You can install it using <code>pip</code> from your command line. We recommend setting up a virtual environment for atopile so that atopile's dependencies don't clash with the rest of your system.</p> <p>It's dead simple with <code>pipx</code> <pre><code>pipx install atopile\n</code></pre></p> How do I install <code>pipx</code>? <p><code>pipx</code> has some dead simple installation instructions here: https://pipx.pypa.io/stable/installation/#installing-pipx</p> <p>atopile should be installed. You can verify that it worked with the following command which should give you the current version of atopile. <pre><code>ato --version\n</code></pre></p> <p> Getting started with atopile - get setup and build your first project from scratch \u2013  32m \u2013 We have a video of how to install atopile and setup your project here.</p>"},{"location":"getting-started/#atopile-compiler-for-development","title":"atopile compiler - for development","text":"<p>atopile can be directly installed from GitHub by cloning the repository into a subfolder of your project root. This could be useful if you want to use the latest version of atopile:</p> <p>Start by making sure you have <code>python@3.11</code> or later installed on your machine.</p> How to install python 3.11 or later <p>To install python 3.11 or later, you can use brew</p> <p><code>brew install python@3.11</code></p> <p>once you create your venv, make sure to run:</p> <p><code>python3.11 -m venv venv</code></p> <p>Setup the venv: <pre><code>python3.11 -m venv venv\n</code></pre> Activate the venv: <pre><code>source venv/bin/activate\n</code></pre></p> <p><pre><code>git clone https://github.com/atopile/atopile.git\n</code></pre> This will create a repository with the latest version of atopile. You can install it using pip:</p> <pre><code>pip install -e atopile\n</code></pre>"},{"location":"getting-started/#vscode-extension-extension-store","title":"VSCode extension - extension store","text":"<p>We recommend using VSCode to run atopile as it will provide syntax highlighting.</p> <p>From VSCode, navigate to the VSCode extensions and install atopile.</p> <p></p> <p>The extension needs to know where your ato compiler's python interpreter is located. There are two ways to do this:</p>"},{"location":"getting-started/#1-easy","title":"1. - Easy","text":"<p>If <code>ato</code> is in your PATH, the extension will find it automatically.</p>"},{"location":"getting-started/#2-harder","title":"2. - Harder","text":"<p>If not, you can set the <code>atopile.interpreter</code> setting in your vscode settings to the path of the <code>ato</code> executable. eg. in your <code>settings.json</code> (): <pre><code>{\n    \"atopile.interpreter\": [\"/path/to/the/python/interpreter/used/for/ato\"]\n}\n</code></pre></p> <p>You can find <code>/path/to/the/python/interpreter/used/for/ato</code> by running <code>ato --python-path</code> in your terminal, where <code>ato</code> is available.</p>"},{"location":"getting-started/#making-a-simple-circuit","title":"Making a simple circuit","text":"<p>To get you started quickly, here is an example of a simple atopile circuit. See the rest of the documentation on how to fully use the atopile language features.</p> <p>Let's build a voltage divider. Start by invoking <code>ato create</code> to create a new project.</p> <p>Once created, open elec/src/your-project.ato and modify it in the following way:</p> your-project.ato <pre><code>from \"generics/resistors.ato\" import Resistor\n\nmodule VoltageDivider:\n    signal top\n    signal out\n    signal bottom\n\n    r_top = new Resistor\n    r_top.footprint = \"R0402\"\n    r_top.value = 100kohm +/- 10%\n\n    r_bottom = new Resistor\n    r_bottom.footprint = \"R0402\"\n    r_bottom.value = 200kohm +/- 10%\n\n    top ~ r_top.p1; r_top.p2 ~ out\n    out ~ r_bottom.p1; r_bottom.p2 ~ bottom\n</code></pre> <p>Now you can build this project and get a voltage divider!</p> <p>Tip</p> <p>The generics library should be installed by default in <code>your-project/.ato/modules/generics</code> directory. If not, run <code>ato install generics</code></p>"},{"location":"git/","title":"Version control using git","text":"<p>git is a powerful way to version control your design and one of the key reason we started atopile. If you don't know about git, we strongly recommend learning it. There is a high chance you will end up loving it.</p>"},{"location":"git/#get-stuff-from-the-server-sync","title":"Get stuff from the server / sync","text":"<p>git fetch origin  git pull"},{"location":"git/#make-a-new-branch","title":"Make a new branch","text":"<p><code>git checkout -b &lt;branch-name&gt;</code></p> <p><code>git checkout -b &lt;branch-name&gt; &lt;from-branch&gt;</code></p> <p>eg. <code>git checkout -b mawildoer/new-feature origin/main</code></p>"},{"location":"git/#save-some-work","title":"Save some work","text":"<p>1.</p> <p><code>git add &lt;whatever-you-wanna-save&gt;</code></p> <p><code>git add .</code>  -- save everything I've changed (including perhaps things we forgot to <code>.gitignore</code>)</p> <p>2.</p> <p><code>git commit</code></p> <p><code>git commit -m \"&lt;message-here&gt;\"</code></p>"},{"location":"git/#push-it-back-for-everyone-else","title":"Push it back for everyone else","text":"<p><code>git push</code> works if you didn't spec a \"from\" branch in <code>git checkout -b ...</code></p> <p><code>git push -u origin HEAD</code> always works</p> <p>Will respond with a way to make a branch:</p> <pre><code>remote:\nremote: To create a merge request for mawildoer/dummy-branch, visit:\nremote:   https://gitlab.atopile.io/atopile/servo-drive/-/merge_requests/new?merge_request%5Bsource_branch%5D=mawildoer%2Fdummy-branch\nremote:\nTo gitlab.atopile.io:atopile/servo-drive.git\n</code></pre> <p>Cmd+ on the link to gitlab"},{"location":"import/","title":"Imports","text":"<p>You can import assets by specifying what you want to import and where you want to import it from using the following syntax within your <code>.ato</code> files:</p> <p><code>from \"where.ato\" import What, Why, Wow</code></p> <p>Notes on that statement: - add quotes on the \"where.ato\" - it's a string - <code>What</code>, <code>Why</code> and <code>Wow</code> are capitalised because they are in the source file. It has to match precisely - it's a type and types should be capitalised, though this isn't enforced and you can import things other than types from other files</p> <p>The import statements are with respect to the current project (the root of which is where your <code>ato.yaml</code> is placed), or within the standard library (<code>.ato/modules/</code>)</p> <p>Warning</p> <p>You'll likely see import statements in the form of <code>import XYZ from \"abc.ato\"</code>. This is a legacy syntax and will be removed in the future. Please use the new syntax.</p> <p>It also doesn't support importing multiple things on the same line.</p>"},{"location":"install/","title":"Install dependencies","text":""},{"location":"install/#components","title":"Components","text":""},{"location":"install/#installing-components-from-jlcpcb","title":"Installing components from JLCPCB","text":"<p>Here is an example on how to install the RP2040 chip from JLCPCB:</p> <p><code>ato install --jlcpcb C2040</code></p> <p>The command will add your footprint and 3D representation to the KiCAD library (named lib in your folder structure) and create an ato file of the component in the elec/src directory.</p>"},{"location":"install/#adding-components-manually","title":"Adding components manually","text":"<p>To manually add components, follow the instructions for creating a component or footprint in the section below.</p>"},{"location":"install/#packages","title":"Packages","text":""},{"location":"install/#browsing-packages","title":"Browsing packages","text":"<p>The atopile package registry contains a list of existing ato packages. Packages usually contain components, module footprints, and layouts that can be reused in other projects.</p> <p>A package usually points to a git repository that contains the design files, in a similar fashion to a standard atopile project.</p> <p>See an example of a package with the generics library.</p>"},{"location":"install/#installing-packages","title":"Installing packages","text":""},{"location":"install/#install-from-the-package-manager-recommended","title":"Install - from the package manager recommended","text":"<p>To install a package, run the following command:</p> <p><code>ato install &lt;your-package-name&gt;</code></p> <p>The package will be added in the .ato/modules/your-package-name directory. It's installed just like existing git repositories that means you can make changes to it and push those changes back to the remote, if you have permissions to do so.</p>"},{"location":"install/#install-from-a-git-repo","title":"Install - from a git repo","text":"<p>To install a package from a git repository, run the following command:</p> <p><code>ato install &lt;your-repository-url&gt;</code></p> <p>The package will be added will be added to your dependencies in a similar fashion than the procedure above. See below for the procedure to specify a specific package.</p>"},{"location":"install/#upgrading-packages-version-management","title":"Upgrading packages &amp; version management","text":"<p>You can pull the latest packages by running:</p> <p><code>ato install --upgrade</code></p> <p>This will pull the latest tag version for the packages. If you wish to further specify which version of the package you'd like to install, you can use semantic versioning in the <code>ato.yaml</code> file. For example, you can request the highest available version of the generics package 1.x.x:</p> <p>ato.yml</p> <pre><code>...\ndependencies:\n- generics^v1.0.0\n</code></pre> <p>Tip</p> <p>The compiler version follows sementic versioning. The required version of your dependencies can be specified using npm's standard.</p>"},{"location":"install/#adding-packages","title":"Adding packages","text":"<p>The top of the atopile package registry contains a form to add packages. Add the name and the link to the git repository (GitLab or GitHub for example) and click submit. Your package should now be available to the community!</p>"},{"location":"install/#adding-custom-footprints","title":"Adding custom footprints","text":"<p>In cases where you can't find the footprint that you'd want to use on JLCPCB or in the atopile package registry, you can also add it manually. KiCAD has a library of footprints you can use on GitLab (those should be installed locally already if you opt-in to install the default library when installing KiCAD, which we recommend you do). From there, you have two options:</p> <p>Add the footprint to your ato project</p> <p>If you have a footprint selected, you can move it to your <code>atopile</code> project in the <code>elec/footprints/footprint.pretty</code> directory. From your component, you can point to that footprint. You also need to connect the footprint pads to signals that you will use throughout your project. For example, if the footprint is called <code>my_footprint.kicad_mod</code> and the pads <code>PAD1</code> and <code>PAD2</code>:</p> <pre><code>component MyComponent:\n    footprint = \"my_footprint\"\n    signal in ~ pin PAD1\n    signal out ~ pin PAD2\n</code></pre> <p>Use footprints from the kicad default library</p> <p>The procedure would be the same as the one outlined above except that you don't have to add the footprint to the atopile <code>elec/footprints/footprint.pretty</code> directory. KiCAD will find it in it's own default library. This will only work if the KiCAD has the default library installed.</p> How to inspect your footprints? <p>To inspect a footprint, you can use KiCAD's footprint editor</p> <p></p> <p>You can also inspect the file itself and find the pads. Here is what they look like: <code>(pad \"1\" smd roundrect (at -0.48 0) (size 0.56 0.62) (layers \"F.Cu\" \"F.Paste\" \"F.Mask\") (roundrect_rratio 0.25) (tstamp f0d6bdbe-8dea-4984-9c52-f76168ceed26))</code></p> How to draw new footprints that aren't in existing libraries? <p>KiCAD provides documentation on how to draw custom footprints here.</p>"},{"location":"kicad/","title":"KiCAD layout","text":""},{"location":"kicad/#kicad-installation","title":"KiCAD installation","text":"<p>To use atopile, you will need to install KiCAD. You can find it on KiCAD's official website.</p>"},{"location":"kicad/#import-netlist-into-kicad","title":"Import netlist into KiCAD","text":"<p>Follow this procedure to import a netlist into KiCAD:</p> <ol> <li>File -&gt; Import Netlist </li> <li>Select the netlist you've just generated. The output is in the terminal, but it should approximately be servo-drive/build/servo-drive.net</li> <li>Make sure you're using unique IDs, rather than designators (though they should work too)</li> <li>Ruthlessly destroy stuff that's not supposed to be there (check boxes on the right) </li> <li>Check the errors - sometimes it's important</li> </ol> <p>In case you want to setup your own project, we have prepared a template with sample <code>ato</code> code and KiCAD project. Find it here.</p> <p>Tip</p> <p>KiCAD needs to know where to look for the project's footprint. The <code>fp-lib-table</code> file points it to <code>build/footprints/footprints.pretty</code> which contains all the footprints. Make sure that is the case under preferences&gt;manage footprint libraries. It should look like this: </p>"},{"location":"kicad/#layout-reuse","title":"Layout reuse","text":"<p>atopile allows you to reuse the layouts that are defined in your dependencies. You will need the atopile KiCAD plugin installed which should happen automatically when installing the atopile cli. You should see those three buttons at the top of your KiCAD interface.</p> <p></p> <p> atopile Layout Reuse \u2013  3m \u2013 atopile Layout Reuse.</p>"},{"location":"kicad/#steps","title":"Steps","text":"<p>1) Start by adding a module to your project using <code>ato install</code>.</p> <p>2) Add an instance of that package's module to your project and build the project</p> <p>3) Open your project's KiCAD layout and import the netlist</p> <p>4) Click the Reload Group button. This will recognize the modules that are in your layout and group them.</p> <p>5) Select the group that you want to apply the auto layout on.</p> <p>6) Click the Download button. THis will apply the layout to that group.</p> <p>Groups will look like that:</p> <p></p> <p>Try it out with the RP2040 module!</p>"},{"location":"kicad/#button-function","title":"Button function","text":"<p> Download button: This button will apply the layout that is defined in your dependency to your current layout.</p> <p> Upload button: This button will save your current layout to the your module. This is useful if you have a module in your current layout that you would like to save in the module and share with other projects.</p> <p> Reload button: This button will create groups of components following the dependencies that you added for your project.</p>"},{"location":"kicad/#how-it-actually-works","title":"How it actually works","text":"<p>As you build your project, a <code>manifest.json</code> is created in the build directory. The manifest links your KiCAD pcb payout file to a <code>&lt;your-project&gt;.layouts.json</code>. This file lists out all the modules that are in your layout and the map of the unique IDs in the current project to the ones in the dependency that you are trying to pull the layout from. It also provides the address of where the layout reuse is located.</p>"},{"location":"maths/","title":"Units and tolerances, assertions and maths","text":"<p>Remember how NASA slung a rocket straight into Mars because of a metric/imperial boo boo?</p> <p>How about we don't do that again.</p>"},{"location":"maths/#units","title":"Units","text":"<p>Resistors's resistances must be a resistance; whether <code>1.23\u03a9</code> (option+Z on OSx), <code>1.23ohm</code>, <code>4.56Kohm</code>, <code>7.89Mohm</code> or similar.</p> <p>Any attribute of any block may have a unit attached written (without a space) after any number.</p> <p>Unsurprisingly, caps capacitances need to be a capacitance; eg. <code>23.4uF</code>, various limits in volts, amperes, degrees and so on.</p> <p>Add units.</p>"},{"location":"maths/#tolerances","title":"Tolerances","text":"<p>Another unfamiliar first-class language feature when dealing with the physical world is the ability (and generally requirement) to spec tolerances for attributes.</p> <p>You could try find a <code>10k\u03a9</code> resistor, but my money says you won't - it'll likely be at least <code>10k\u03a9 +/- 0.1%</code> (which you can write!)</p> <p>Tolerances can be written in the forms of: - <code>1V to 2V</code> - <code>3uF +/- 1uF</code> - <code>4Kohm +/- 1%</code></p> <p>These are hopefully sufficiently intuitive as to not warrant further explanation \ud83e\udd1e</p>"},{"location":"maths/#units-and-tolerances","title":"Units and Tolerances","text":"<p>With Units and Tolerances together, we can define Physical attributes.</p> <p>There's quite a few legal ways to combine them!</p> <ul> <li><code>3V to 3.6V</code> perhaps for a supply rail</li> <li><code>3V +/- 10mV</code> maybe for a reference</li> <li><code>4.7uF +/- 20%</code> for a generic cap</li> <li>even <code>25lb +/- 200g</code> \ud83e\udd23</li> </ul>"},{"location":"maths/#sweet-so-now-ive-got-all-these-values-around-the-place-what-can-i-do-with-them","title":"Sweet, so now I've got all these values around the place... what can I do with them?","text":"<p> Maths </p> <p>There are two things that atopile can do for you with these values: 1. Check that assertions about their relationships to one another are true 2. Solve systems of constraints based on these relationships for find component values</p> <p>This maths is all done including the units and tolerances, so you can be sure absolutely sure everything always works.</p> <p>Use the <code>assert</code> keyword to apply constraints on the values of attributes to one another.</p> <p>Supported operators are currently <code>&lt;</code>, <code>&gt;</code> and <code>within</code> (all are inclusive of the bounds).</p> <pre><code>a = 1 \u00b1 0.1\nb = 2 \u00b1 0.2\nc: resistance  # variable declaration without assignment\n\nassert a &lt; b  # always true before 0.9 and 1.1 (the bounds of a) are both lower than the bounds of b (1.8 and 2.2)\nassert a &gt; b  # always false --&gt; Will yield a failure at compile time\nassert c within 1Kohm to 10Kohm  # first solved for, then the solution is independently checked at the end of the build\n</code></pre>"},{"location":"maths/#assertion-checking","title":"Assertion checking","text":"<p>Who else has had conversations along the lines of \"Is it cool if I tweak the value of this resistor?\" \"Uhh... good question! I think so?\".</p> <p>Well, do we have a treat for you (both the person asking and the person being asked)!</p> <p>atopile will check all the assertions in your design for you - giving you a heap more freedom to play with the values of things, knowing your computer is taking care of checking it for you.</p> <p></p>"},{"location":"maths/#solving","title":"Solving","text":"<p>I'm not sure about you, but I (Matt) am pretty dumb and don't love working too hard. Perhaps you've got a better method, but generally when I'm trying to find resistor values for something even as simple as a voltage divider, I guess one that seems approximately right, then calculate the other - giving me something that doesn't exist, before finally checking through a few other options close-by until finding a pair that works.</p> <p>This is fine and dandy as long as you only care about the ratio of a voltage divider, but as soon as you need to check what that does for your regulators output voltage? Ergh, fine! What about the extremes of the tolerances on those resistors? Fine I'll do it once - but I swear if someone goes to tweak those values for whatever reason, I am unlikely to be pleased.</p> <p>So, let's get atopile to do it for us!</p> <p>atopile will automatically solve systems of constraints for you with free variables, and check that the values of attributes are within their tolerances.</p> <p></p>"},{"location":"roadmap/","title":"Roadmap","text":"<p>What the atopile core team are planning to make of this project and approximately how we're planning to get there.</p>"},{"location":"roadmap/#near-term-features","title":"Near-term Features","text":"<p>Within each category, the features are listed in approximate order of priority.</p> <p>The top-level features themselves are too, but we'll tackle the basics of some domains before the more advanced features of others.</p> <p>There's a lot to come</p> <p>This is a living document, not making promises, but it's a good place to start if you're interested in what's coming up. Additionally, there's a lot (more than not) that's not here yet, either because we haven't articulated it yet, and because this page would be enormous if we did.</p>"},{"location":"roadmap/#reuse","title":"Reuse","text":""},{"location":"roadmap/#language-features","title":"Language Features","text":"<ul> <li> Inheritance <code>from</code></li> <li> Retyping / Replacement <code>-&gt;</code></li> <li> Physical units <code>10kOhm</code> <code>1uF</code></li> <li> Tolerances <code>10kOhm +/- 1%</code></li> <li> Equations / Expressions; relate the parameters of components to specs and solve at compile time</li> <li> Composition / Traits</li> <li> Typing; what is allowed to or must be connected to what?</li> </ul>"},{"location":"roadmap/#component-selection","title":"Component Selection","text":"<ul> <li> MVP select jelly-beans from JLCPCB</li> <li> Move component database to cloud in order to support more components and component types</li> </ul>"},{"location":"roadmap/#quality-control","title":"Quality Control","text":"<ul> <li> Generate gerbers in CI</li> <li> Lock files (ensuring consistent builds)</li> <li> DRC in CI</li> <li> Check source code and layouts are in sync</li> </ul>"},{"location":"roadmap/#package-management","title":"Package Management","text":"<ul> <li> MVP -&gt; https://packages.atopile.io/</li> <li> Search function</li> <li> Package details page</li> <li> Package statistics</li> <li> Authentication for uploading packages</li> </ul>"},{"location":"roadmap/#dev-tools","title":"Dev tools","text":"<ul> <li> VSCode extension</li> <li> VSCode basic language server (goto definition)</li> <li> Linting</li> <li> Schematic viewer; imagine side-by-side with the code</li> <li> KiCAD extension</li> </ul>"},{"location":"roadmap/#non-goals","title":"Non-goals","text":"<p>Things we don't have planned out.</p> <ul> <li>GUI editor</li> <li>No compatibility with <code>xyz</code> ECAD tool: it takes away from the core of the project; to fundamentally change how hardware engineers work. Currently integrated tools are largely seen as stepping stones away from the explicit interfaces of the past.</li> </ul>"},{"location":"spin/","title":"SPIN","text":"<p>SPIN is a BLDC motor controller using the SimpleFOC library. Designed as a reference project, hopefully serving as a starting point for your own projects with motor control!</p> <p></p>"},{"location":"spin/#specs","title":"Specs","text":"<ul> <li>3-phase BLDC nema 17 motor</li> <li>12-24V power supply</li> <li>2A continuous current, 5A peak current</li> <li>14bit magnetic encoder (0.02\u00b0 resolution)</li> </ul>"},{"location":"spin/#features","title":"Features","text":"<ul> <li>XT30 power connector (x2 for daisy chaining)</li> <li>JST-GH 4-pin CAN bus connector (x2 for daisy chaining)</li> <li>Stemma/Qwiic I2C connector</li> <li>Addressable RGB LEDs for status indication</li> <li>USB-C for programming and debugging</li> </ul>"},{"location":"spin/#roadmap","title":"Roadmap","text":"<p>Second version of the board is currently in manufacturing to add CAN bus and I2C communication.</p> <ul> <li> Power supply bring-up</li> <li> Open loop velocity control</li> <li> Closed loop current control</li> <li> Position control with magnetic encoder</li> <li> CAN bus control (position, velocity, current)</li> <li> CAN bus motion profile</li> <li> I2C communication</li> <li> Enumeration with multiple devices</li> </ul>"},{"location":"spin/#documentation","title":"Documentation","text":"<p>Interested in building your own SPIN or helping out with the project? Check out the repo and discord for more information on how to get started!</p>"},{"location":"swoop/","title":"Swoop","text":"<p>Swoop is an open-source motion based flight controller for drones. It uses an IMU to generate commanded yaw, pitch, and roll angles, and sends these commands to the flight controller over ExpressLRS.</p> <p></p>"},{"location":"swoop/#specs","title":"Specs","text":"<ul> <li>9-axis IMU (mag, gyro, accel)</li> <li>RP2040 (sensor fusion, throttle, status indication)</li> <li>ESP32 S3 (ExpressLRS)</li> <li>SX1280 transceiver (compatible with ExpressLRS)</li> <li>Powered by 1000mah internal LiPo battery (~ 4hrs of flight time)</li> </ul>"},{"location":"swoop/#block-diagram","title":"Block Diagram","text":""},{"location":"swoop/#features","title":"Features","text":"<ul> <li>Status LEDs</li> <li>USB-C for programming and debugging</li> <li>hall-sensor for throttle control</li> </ul>"},{"location":"swoop/#roadmap","title":"Roadmap","text":"<p>Second version of the board is currently in manufacturing to add CAN bus and I2C communication.</p> <ul> <li> Power supply bring-up</li> <li> Battery charging circuit bring-up</li> <li> IMU bringup</li> <li> IMU calibration</li> <li> IMU sensor fusion</li> <li> ExpressLRS integration (FLRC)</li> <li> Binding with ExpressLRS receivers</li> <li> Add display and buttons for ExpressLRS configuration</li> </ul>"},{"location":"swoop/#initial-testing","title":"Initial Testing","text":""},{"location":"swoop/#documentation","title":"Documentation","text":"<p>Interested? We are looking for collaborators! Check out the repo and discord for more information on how to get started!</p>"},{"location":"types/","title":"Basic types &amp; Connections","text":"<p>There's a handful of major types that you'll use in your <code>.ato</code> files, falling into two categories: blocks and nodes.</p> <p>Blocks represent something that can contain other things. They provide an abstraction over their contents. For example, a block could be a power supply chip and all the passive components around it.</p> <p>Nodes are elements you can connect to.</p> <p>Block types are: - <code>component</code> - represents exactly one component - <code>module</code> - a collection of components and other modules - <code>interface</code> - walks the line between a block and a node. It's a connectable block that lets you connect multiple nodes at a time</p> <p>Node types are: - <code>pin</code> - represents a physical pin/pad on a package - <code>signal</code> - represents a logical signal that can be connected to other signals</p>"},{"location":"types/#block-definition","title":"Block definition","text":""},{"location":"types/#components","title":"Components","text":"<p>Here is an example of a block (in this case, a <code>component</code>) created within a file named <code>resistor.ato</code>:</p> <pre><code>component Resistor:\n    signal p1  # declare a signal named \"p1\"\n    p1 ~ pin 1  # connect that \"p1\" signal with pin 1\n    signal p2 ~ pin 2  # declare a signal named \"p2\" and connect it with pin 2 in one line\n    footprint = \"R0402\"\n</code></pre>"},{"location":"types/#footprints-for-resistors-and-capacitors","title":"Footprints for resistors and capacitors","text":"<p>For convenience, the footprints for resistors and caps can be defined like so</p> Package Resistor footprint Capacitor footprint 01005 R01005 C01005 0201 R0201 C0201 0402 R0402 C0402 0603 R0603 C0603 0805 R0805 C0805 1206 C1206"},{"location":"types/#modules","title":"Modules","text":"<p>Here is an example of a <code>module</code> definition, in this case a resistor divider:</p> <pre><code>from \"generics/resistors.ato\" import Resistor\n\nmodule YourModule:\n    signal top\n    signal out\n    signal bottom\n\n    r_top = new Resistor\n    r_top.footprint = \"R0402\"\n    r_bottom = new Resistor\n    r_bottom.footprint = \"R0402\"\n\n    top ~ r_top.p1; r_top.p2 ~ out\n    out ~ r_bottom.p1; r_bottom.p2 ~ bottom\n</code></pre> <p>A module can contain an arbitrary amount of components, modules, signals, and interface instances.</p>"},{"location":"types/#interfaces","title":"Interfaces","text":"<p>Here is an example of an <code>interface</code> definition; in this case, a CAN interface</p> <pre><code>interface YourInterface:\n    signal CANH\n    signal CANL\n</code></pre> <p>An interface can contain an arbitrary amount of signals.</p> <p>Interfaces can be connected together with the <code>~</code> operator like so:</p> <pre><code>interface_1 = new YourInterface\ninterface_2 = new YourInterface\n\ninterface_1 ~ interface_2\n</code></pre> <p>Two interfaces can be connected as long as they contain the same signals.</p>"},{"location":"types/#node-definition","title":"Node definition","text":""},{"location":"types/#signal-definition","title":"Signal definition","text":"<p>Signals can be useful as they allow you to name a connection point used throughout your design. Here is an example with a ground signal:</p> <pre><code>signal gnd\n</code></pre> <p>Signals can be connected in the following way:</p> <pre><code>signal enable_pin\nsignal vcc\nenable_pin ~ vcc\n</code></pre>"},{"location":"types/#pin-definition","title":"Pin definition","text":"<p>Pins can be defined in a similar way to signals. Pins are used specifically within components to tie your signals back to your footprints. The pin should have the same name as the copper pads in your footprint.</p> <p>We usually recommend creating a signal within your component and tying it to your pin. That gives you a meaningful signal to connect to instead of an ephemeral pin. For example:</p> <pre><code>signal vcc ~ pin 1\n</code></pre>"},{"location":"view/","title":"atopile viewer","text":"<p>To use the viewer, invoke the <code>ato view</code> cli command:</p> <pre><code>ato view\n</code></pre> <p>If you have multiple build configuration, specify the one you would like to view with:</p> <pre><code>ato view -b &lt;your-build-config-name&gt;\n</code></pre> <p>The viewer will spool up a server on your local machine at http://127.0.0.1:8080.</p>"},{"location":"view/#viewer-interfaces","title":"Viewer interfaces","text":""},{"location":"view/#block-diagram","title":"Block diagram","text":"<p>The block diagram is meant to provide a view that resembles your code structure. In the block diagram view, you will see the same signals and interfaces that are present in your code as well as how they interact with each other. This view will help you navigate through your project and it's structure.</p>"},{"location":"view/#schematic","title":"Schematic","text":"<p>The schematic view follows a more standard view of your design. This view can be used for documentation or inspecting a more concrete view of your final circuit. The schematic view can be enabled by navigating with the block diagram to the block you want to inspect and pressing the schematic button. You can switch back to block diagram by pressing the same button.</p> <p>The schematic diagram will represent all the components that are at the level or below the current module.</p>"},{"location":"view/#supported-components","title":"Supported components","text":"<p>For a component to show up on the schematic, it needs to be an instance of a component in the generics library. Here are the current components we support:</p> <ul> <li>Resistor</li> <li>Inductor</li> <li>Capcitor</li> <li>LED</li> <li>Powr</li> <li>NPN</li> <li>PNP</li> <li>Diode</li> <li>SchottkyDide</li> <li>ZeneDiode</li> <li>NFET</li> <li>PFET</li> <li>Opamp</li> </ul> <p>Other larger components will show up as scattered signals that can be moved around to relevant places.</p>"},{"location":"view/#moving-rotating-mirroring-components","title":"Moving, rotating, mirroring components","text":"<p>To rotate, you can select a component and press the <code>R</code> key. To mirror a signal, you can use the <code>F</code> key. To move a component, simply drag and drop it with your mouse.</p>"},{"location":"view/#navigate-within-your-design","title":"Navigate within your design","text":"<p>To navigate within a module or component, simply click on it. return: This button brings you back to the parent module re-layout: This button re-lays out the modules for you schematic/block diagram: Switch between the two viewing modes reload: Loads the latest changes for your code. This feature hasn't been enabled from the block diagram yet.</p>"},{"location":"view/#inspect-links","title":"Inspect links","text":"<p>Clicking on a link in the block diagram will show the source and target address that the link is connection. Those could either be two signals or two compatible instances of an interface.</p>"},{"location":"view/#features-currently-not-supported-but-planned","title":"Features currently not supported (but planned)","text":"<ul> <li>Saving the position of blocks and components</li> <li>Inspecting a links pin to pin connections</li> <li>Expanding and contracting modules (instead of navigating in and out of modules)</li> <li>A decent way to see components and their pins</li> </ul> <p>Join us on discord if you have feedback about the viewer!</p>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/2024/02/29/be-assertive-/","title":"Be assertive \ud83d\udcaa","text":""},{"location":"blog/2024/02/29/be-assertive-/#check-yoself-before-you-wreck-yo-design","title":"Check yo'self before you wreck yo'... design","text":"<p>atopile has your back when it comes to ensuring your design is correct. With the new assertion feature, you can apply constraints on attributes of your design.</p> <ul> <li>Make sure voltage inputs on ICs are withing operational ranges</li> <li>Avoid exceeding power limits on FETs</li> <li>Check temperature sensors function over their entire operating range</li> </ul> <p>Think of this as unit tests for your electronics! \ud83e\udd29</p>"},{"location":"blog/2024/02/29/be-assertive-/#think-in-specs-let-the-computer-find-the-components","title":"Think in specs \ud83e\udde0, let the computer find the components","text":"<p>atopile can find suitable component values for you, to configure your design in terms you want to think about.</p> <p>Tell your filters what you want their cut-off to be, and let atopile find the right resistor and capacitor values for you.</p> <p>Use code to spec what voltage you want your regulator to output, and let atopile find the resistors that meet spec for you!</p>"},{"location":"blog/2024/02/02/trivial-mistakes-are-expensive-/","title":"Trivial mistakes are expensive \ud83e\udd11","text":"<p>Continuous integration / continuous deployment (CI/CD) is does things in software like running tests and deploying code automatically.</p> <p>We've unfortunately been a little too responsible for some pretty expensive trivial mistakes in the past, so it's a key thing we wanted to focus on in <code>atopile</code>.</p> <p>Instead of all shaking hands and totally agreeing that this local export named \"pcb-final-final-final\" is what we're going to spend serious money on - we can generate the manufacturing files on a trusted server</p> <p> </p> <p>... and stamp them with the precise version of the source-code used to create them!</p> <p></p> <p>No more export mistakes \ud83d\udc4c. Plus, it makes ordering boards super easy!</p> <p>Matt</p>"},{"location":"blog/2024/01/31/cloud-components/","title":"Cloud Components","text":"<p>I am pretty excited about this one. In our latest release 0.2.5, we are introducing 'Cloud Components' - a way to parametrically define and select components from a server.</p>"},{"location":"blog/2024/01/31/cloud-components/#how-it-works","title":"How it works","text":"<p>First step is defining the requirements of the component, much like you would in a digikey search. Currently our library has support for resistors and capacitors with experimental support for diodes, inductors, and FETs. Here's an example of how you would define a few components: <pre><code>resistor = new Resistor\nresistor.value = 10kohm +/- 20%\nresistor.package = \"0603\"\n\ncap = new Capacitor\ncap.value = 1uF +/- 10%\ncap.package = \"0603\"\n\n\n#### experimental ####\nfet = new NFET\nfet.current_a = 30A to 100A\nfet.drain_source_voltage_v = 30V to 100V\n\ninductor = new Inductor\ninductor.inductance = 1uH to 10uH\ninductor.current = 3A to 5A\n\ndiode = new Diode\ndiode.forward_voltage = 7V to 9V\ndiode.impedance = 1ohm to 10ohm\ndiode.power_dissipation = 5W to 60W\n</code></pre> At build time, we take the requirements and send them to our component server, which filters parts in our library for the specified requirements. The server then sorts the parts by price and availability, and returns the best matches. These components are then downloaded and added to your BOM and netlist.</p> <p></p>"},{"location":"blog/2024/01/31/cloud-components/#footprints","title":"Footprints","text":"<p>This was a bit of a pain. This is pretty simple for things like resistors and caps, but becomes a little more complex for devices like mosfets that might have three pins on some parts and eight on others. Our current solution, which admittedly is a bit of a hack, stores a muated footprint in the server for each part, downloads it and adds it to your library.</p> <p>For example, here is a multi-pin mosfet, you can see that the pin names have been mutated to their corresponding signals:</p> <p></p>"},{"location":"blog/2024/01/31/cloud-components/#why-this-is-a-big-deal","title":"Why this is a big deal","text":"<p>The way circuits are defined today requires us as designers to be explicit as to which part number each component will have, in the process loosing information about why you chose that component. If a design at your company has a component shortage and you are assigned the task to find a replacement, how do you know which part to choose, what are the requirements? If you are luck there might be a design document or confluence page you can scroll through to reverse engineer the design and check new parts against it. If you are unlucky, the guy who designed it left the company and only took paper notes.</p> <p>By capturing the requirements in your source code, the information is preserved and can be used even years later to find a suitable part. I imagine a future where automated systems can track component pricing and inventory, automatically finding cost down opportunities, or alerting you when a part is going end of life and proposing a replacement.</p> <p>More immediately, as a designer making a quick turn board, I don't want to spend time browsing digikey, seeing what is available, checking if we have it in our companies component library, only to hear back from the vendor that the component is now out of stock and they need me to pick a new one. Thats enough to make a grown man cry, some days. Instead, we can have the tool generate a list of alternatives that meet the requirements and allow the vendor to pick from that list.</p>"},{"location":"blog/2024/01/31/cloud-components/#what-is-next","title":"What is next?","text":"<p>I believe that a fundamental transformation of how we capture circuit information is needed to enable the next generation of tools. In order to make our tools truly smart, we need to come up with ways to communicate design intent, not just one explicit implementation. Concretely, we are working on:</p> <ul> <li>Adding more component types to the server</li> <li>Adding support for project level requirements and constraints: AECQ100, Environmental conditions, etc</li> <li>Component traits - how to generically describe complex components (blog post coming soon)</li> </ul> <p>Stay tuned for more updates!</p> <p>Narayan</p>"},{"location":"blog/2024/02/09/why-on-earth-did-you-create-a-new-language-/","title":"Why on earth did you create a new language? \ud83e\udee3","text":"<p>It's a good question! Making people learn something new is a huge barrier to entry, ignores the wealth of community support from existing languages and can be a bit of a pain to maintain.</p> <p>This iteration of the project actually came after first working with and then modifying an awesome project called SKiDL (https://github.com/devbisme/skidl). SKiDL takes the approach of using Python. Since it's procedural, turing complete and has a rich eco-system - people use to that and there aren't standard composable ways of designing things. Instead of describing your board, you (practically) write a script that generates your board. It entangles your targets with your source-code and can make it difficult to understand the ultimate outcome of what you've written.</p> <p>We are trying to make it as readable and friendly as possible, our expectation is our users will likely have some experience with Python and perhaps a little C back in school, so making it clear and approachable is front of mind. Ideally some parts of code should \"look\" like the schematic, eg. <code>power.vcc ~&gt; resistor ~&gt; led ~&gt; power.gnd</code>.</p> <p>Units and tolerances are core to our language, the physical world is 'fuzzy' and having a good way to deal with those is pretty important. There's a few operators and first-class language features we wanted as well, (like units and tolerances eg. <code>3.3V +/- 100mV</code>) that just aren't the same when embedded in a string, or class init method.</p> <p>Additionally, since it's a potentially very long program, it was hard to write good language support around (a language server for VSCode, a schematic visualiser etc...) that were snappy, responsive and lent to examining modules as well as the whole program.</p> <p>Worth noting; we're probably going to try make our language more like Python, than less over the coming little while.</p> <p>Happy coding! \ud83d\ude80</p> <p>-- Matt</p>"},{"location":"blog/2024/02/02/-layout-reuse-keeps-getting-better-/","title":"\u2728 Layout Reuse Keeps Getting Better \ud83d\ude80","text":"<p>Now with traces and vias \ud83d\udc4c</p> <p> </p> <p>Happy designing! \ud83c\udf89</p> <p>Matt</p>"},{"location":"blog/2024/02/02/-layout-reuse-/","title":"\u2728 Layout Reuse \u2728","text":"<p>Huge shout out to @nickkrstevski for this awesome new feature!</p> <p>You can now reuse parts placement across designs. This is a huge time saver for designs - particularly those with a lot of common modules.</p> <p> </p>"},{"location":"blog/2024/02/02/-layout-reuse-/#omg-how","title":"OMG, How?","text":"<p>Usage of the <code>ato</code> CLI will automatically install the hook for the atopile plugin to KiCAD. All you need to do is hit the sync \ud83d\udd04 button to group the components into the modules that have layouts associated, then hit pull \u2b07\ufe0f to use that layout. If you want to save a layout to a module, you can do so with the push \u2b06\ufe0f button.</p> <p>Happy designing! \ud83c\udf89</p> <p>Matt</p>"},{"location":"blog/2024/02/06/make-hardware-flow/","title":"Make hardware flow","text":"<p>My dad taught me the technical details of everything for as long as I can remember. For my 7<sup>th</sup> Christmas, I got a lawn-mower - to tear the engine off and turn into a go-kart. I was absolutely stoked.</p> <p>As Narayan and I grew up, we spent every weekend building things. We were always scheming about the next project, and we were always building something. We built a CNC machine, a liquid-fueled rocket motor, and a drone. We were always trying to make things better, faster, and more efficient. We were always trying to make things work better.</p> <p>More than any of the individual projects, the thing that I always got most stoked about was new tools. We converted a milling machine to CNC an axis at a time by first 3D printing and then machining each of the axes brackets. We had to take a second pass at the first two axes because the 3D printed parts were sloppy enough that the machined brackets they created still had too much play for comfort. Man, that was a great project. And the endeavour landed us more offers for contract work (as ~17 year-olds) than we could handle.</p> <p>One specific part of that project I wanted, and wanted for years, were low-cost tightly integrated servo drives. I wanted to make a PCB with 4 servo controllers on it that meant I would only need to run cables out to the motors and I could control the whole system form a single PCB - similar to 3D printer controllers. We're finally getting close! https://github.com/atopile/spin-servo-drive</p> <p>My subsequent decade through university and industry made me consciously realise why people kept trying to pay us - it's far too hard and slow to make hardware fast enough to stay in a flow state and learn fast enough that failing is acceptable.</p> <p><code>atopile</code> will make high-quality hardware engineering flow the same way great software development does - and make engineers everywhere feel like how our scrappy younger selves did.</p>"},{"location":"blog/2024/01/31/from-weekend-projects-to-reinventing-hardware-design/","title":"From Weekend Projects to Reinventing Hardware Design","text":""},{"location":"blog/2024/01/31/from-weekend-projects-to-reinventing-hardware-design/#early-days-can-we-build-a-predator-drone","title":"Early Days: Can we build a predator drone?","text":"<p>Matt and I met at camp when we were thirteen and quickly became mates. We chatted the whole twelve hour bus ride home, scheming about the enormous drone we were going to build, looking back at it, we were a bit ambitious.</p> <p>The next decade of weekend weekends Matt and I spent together stand out. They weren't filled with typical childhood pastimes; instead, we immersed ourselves in building and creating. Our projects were modest \u2013 from simple drones to CNC machines. I'll never forget our attempt at a liquid-fueled rocket motor. Igniting it was a disaster, but everything else from the servo-controlled throttling to the large blast shield worked quite the treat - not bad, for about a week's worth of evenings after work!</p>"},{"location":"blog/2024/01/31/from-weekend-projects-to-reinventing-hardware-design/#stepping-into-the-professional-world","title":"Stepping into the Professional World","text":"<p>Our first proper tech jobs were at Tesla and Lilium. We were eager to translate our weekend tinkering to the real world. At these companies, we learned a lot about manufacturing and bringing products to market. The technology and talent were inspiring, but we noticed the pace of innovation was slower and more traditional than we expected.</p>"},{"location":"blog/2024/01/31/from-weekend-projects-to-reinventing-hardware-design/#facing-industry-realities","title":"Facing Industry Realities","text":"<p>Eventually, we both ended up at Tesla together, during which time we met Tim. We quickly found common ground in our experiences. Even though we were part of some exciting projects, the reality of day-to-day work often meant dealing with a lot of repetition and slow-moving processes. The job started to feel less about innovation and more about navigating through routine procedures. It wasn't the dynamic environment we had dreamed of, it was becoming just a job.</p>"},{"location":"blog/2024/01/31/from-weekend-projects-to-reinventing-hardware-design/#a-shift-in-perspective-the-seed-of-an-idea","title":"A Shift in Perspective: The Seed of an Idea","text":"<p>Continuing the trend of the CNC machines we built growing up - our personal projects often revolved around making things to make things. It was clear there must be a better way to describe hardware. Mulling this led to pivotal realization: What if we could streamline hardware design using language-based descriptions? In my day job, our team was managing 10+ designs each disconnected from the other, meaning it could take us years to roll out improvements across all of them. The idea of simply making a PR for each to update that particular module sounded too good to be true.</p>"},{"location":"blog/2024/01/31/from-weekend-projects-to-reinventing-hardware-design/#our-vision-a-humble-hope-for-change","title":"Our Vision: A Humble Hope for Change","text":"<p>We\u2019re not claiming to have all the answers or to revolutionize the industry overnight, but we do have a vision: a future where tools keep engineers in their flow state - whether working on teams small or large, no matter how complex the project. We believe this will make the design process significantly faster and less costly, bringing us closer to the agility and joy of those weekend projects from our youth.</p>"},{"location":"blog/2024/01/31/from-weekend-projects-to-reinventing-hardware-design/#an-invitation-to-join-our-journey","title":"An Invitation to Join Our Journey","text":"<p>This journey is just beginning, and there\u2019s a long road ahead. We\u2019re sharing our story not just to talk about our idea, but to invite collaboration, feedback, and shared learning. Together, we can explore ways to bring a new level of dynamism and creativity to hardware design. We\u2019re excited about the future and we hope you\u2019ll join us in this endeavor.</p> <p>Narayan</p>"},{"location":"blog/2024/01/31/composable-electronics/","title":"Composable Electronics","text":"<p>How do we make designing electronics more like playing with legos? We need to standardize the building blocks, how they can be connected together and publish 'instruction manuals' that describe how to connect them up to make something useful.</p>"},{"location":"blog/2024/01/31/composable-electronics/#the-blocks","title":"The blocks","text":"<p>How do you describe what a component is? Today we rely on a language description in a datasheet and a clever human to interpret it. The information is not easily interpretable by a computer, which makes it hard to automate or augment the design process.</p> <p>We need a way to embed key information into the source files.</p>"},{"location":"blog/2024/01/31/composable-electronics/#what-are-the-functional-blocks-inside-the-chip","title":"What are the functional blocks inside the chip?","text":"<p>Here is a simple example of a buck converter IC.  Lets try simplify this into a few functional blocks. Lets say the 'controller' is a block that takes in a voltage outputs a switching node, with a feedback pin. We can just use a NFET component for the fet. So in ato code we could define this as: <pre><code>component LM2841:\n    controller = new BuckController\n    nfet = new NFET\n</code></pre></p>"},{"location":"blog/2024/01/31/composable-electronics/#connecting-and-configuring-the-blocks","title":"Connecting and configuring the blocks","text":"<p>To more completely describe the internals of the IC, we need to define how the blocks are connected and what their properties are. Below we are connecting the NFET to the controller, connecting the blocks to the outputs and configuring the voltage and current limits. <pre><code># connect blocks to pins\ncontroller.feedback ~ fb\ncontroller.power_in.vcc ~ vin\ncontroller.power_out.gnd ~ gnd\nnfet.drain ~ sw\n</code></pre> We will also need to add in any specifics required by this particular IC, like a bootstrap capacitor and a pull-up on the enable pin that ill leave out of this example.</p>"},{"location":"blog/2024/01/31/composable-electronics/#the-instruction-manual","title":"The Instruction Manual","text":"<p>Following through with our buck converter example, lets build a description of how to connect the blocks together to make a buck converter. </p> <p>To start, lets make a new 'topology' and instantiate the required blocks. <pre><code>topology Buck:\n    # Define external interfaces\n    power_in = new Power\n    power_out = new Power\n\n    # Define blocks\n    inductor = new Inductor\n    output_cap = new Capacitor\n    input_cap = new Capacitor\n    diode = new Diode\n    controller = new BuckController\n    nfet = new NFET\n    feedback_divider = new VDiv\n</code></pre></p> <p>Next, lets connect the blocks together. <pre><code>    # Connect internal components\n    controller.drive ~ nfet.gate\n    # Method to chain dipole components (feedback welcome)\n    power_in.vcc ~ nfet ~ inductor ~ power_out.vcc\n    diode.anode ~ gnd\n    diode.cathode ~ inductor.1\n\n    # Feedback divider (input is a power interface)\n    feedback_divider.input ~ power_out\n    feedback_divider.output ~ controller.feedback\n\n\n    # Connect bypass capacitors\n    power_in ~ input_cap\n    power_out ~ output_cap\n\n    # We might want to define some equations to make the buck more intuitive to use\n    eqn: power_out.voltage = feedback_divider.input.voltage\n    eqn: controller.feedback.voltage = feedback_divider.output.voltage\n</code></pre></p> <p>Finally, we need a way to relate the two. Let now create a specific instance of the topology and define the parameters. <pre><code>buck = new Buck\nic = new LM2841\n\n# Map the IC to the topology using the replacement operator\nbuck.controller -&gt; ic.controller\nbuck.nfet -&gt; ic.nfet\n\n# Configure the buck components\nbuck.inductor.inductance = 10uH +/- 20%\ninput_cap.capacitance = 10uF +/- 20%\noutput_cap.capacitance = 10uF +/- 20%\n\n# Configure output voltage\nbuck.power_out.voltage = 5V +/- 5%\n</code></pre></p> <p>That might all feel like alot of work, until you realize that the topologies and components are reusable and only need to be defined once. You can design a buck converter using just that last block of code and a few imports.</p> <p>If you are interested in checking out the full example, you can find it here</p> <p>We have a few language features in the pipeline that will enable this type of workflow in the near future.</p> <p>Narayan</p>"},{"location":"blog/archive/2024/","title":"2024","text":""},{"location":"blog/category/release/","title":"Release","text":""},{"location":"blog/category/about-us/","title":"About us","text":""},{"location":"blog/category/future/","title":"Future","text":""}]}